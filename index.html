<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>ThreeJS</title>
<style>
body {
	background:#000;
	overflow:hidden;
	}
</style>
<script src="lib/three.js-master/build/three.min.js"></script>
<script src="src/functions.js"></script>
 
<script>

window.onload = function () {

var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

var grid = [];
var gridWidth = 25;
var gridDepth = 30;
var gridStartX = 0;
var cubePadding = 1.5;
var cubeColors = [0x81b8d7, 0x73adce, 0x63a0c3];
var scrollSpeed = 0.5;
var cameraVX = 0;
var cameraVY = 0;
var cameraAccel = 0.05;
var cameraMaxVelocity = 0.25;
var cameraMinAltitude = 3;
var rollSpeed = 0.01;

// build grid of cubex`s
for(var i=0;i<gridDepth;i++) {
	var row = [];
	
	for (var j = 0; j <= gridWidth; j++) {
		if(getRandomInt(0,70) == 9) {
			var geometry = new THREE.CubeGeometry(getRandom(1,2),getRandom(15,26),getRandom(1,2));
		} else var geometry = new THREE.CubeGeometry(getRandom(2,3),getRandom(2,4),getRandom(2,3));
		var cubeColor = cubeColors[getRandomInt(0,cubeColors.length-1)];
		
		var material = new THREE.MeshBasicMaterial( { color: cubeColor } );
		var cube = new THREE.Mesh( geometry, material );
		cube.position.x = gridStartX + j + j*cubePadding;
		cube.position.z = i  + i*cubePadding;
		scene.add(cube);
		row.push(cube);
	}
	grid.push(row);
}
// LIGHT
	var light = new THREE.PointLight(0xffffff);
	light.position.set(0,150,100);
	//scene.add(light);
	
// FLOOR
	var floorTexture = new THREE.ImageUtils.loadTexture( 'gfx/checkerboard.png' );
	floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
	floorTexture.repeat.set( 10, 10 );
	var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
	var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
	var floor = new THREE.Mesh(floorGeometry, floorMaterial);
	floor.position.y = -20;
	floor.rotation.x = Math.PI / 2;
	scene.add(floor);

function init() {

	camera.position.z = 30;
	camera.position.y = 4;
	camera.position.x = (gridWidth + gridWidth*cubePadding)/2;


	window.addEventListener('keyup', function(event) { Key.onKeyup(event); }, false);
	window.addEventListener('keydown', function(event) { Key.onKeydown(event); }, false);
	
	render();
	
}

function render() {
	
	if (Key.isDown(Key.LEFT)) {
		cameraVX -= cameraAccel;
		if (cameraVX < -cameraMaxVelocity) cameraVX = -cameraMaxVelocity;
		camera.rotation.z += rollSpeed;
	} else {
		if (camera.rotation.z > 0) camera.rotation.z -= rollSpeed;
		if (cameraVX < 0 ) {
			cameraVX += cameraAccel;
			if (cameraVX > 0) cameraVX = 0;
		}
	}
	
	if (Key.isDown(Key.RIGHT)) {
		cameraVX += cameraAccel;
		if (cameraVX > cameraMaxVelocity) cameraVX = cameraMaxVelocity;
		camera.rotation.z -= rollSpeed;
	} else {
		if (camera.rotation.z < 0) camera.rotation.z += rollSpeed;
		if (cameraVX > 0 ) {
			cameraVX -= cameraAccel;
			if (cameraVX < 0) cameraVX = 0;
		}
	}	
	
	var adjustedScroll = scrollSpeed;
	
	if (Key.isDown(Key.UP)) {
		adjustedScroll *= 2;
	} 
	if (Key.isDown(Key.DOWN)) {
		adjustedScroll /=2 ;
	} 
	

	camera.position.z -= adjustedScroll;
	camera.position.x += cameraVX;
	
	var frontLeftCube = grid[grid.length-1][0];
	if (frontLeftCube.position.z > camera.position.z) {
		var lastRow = grid.pop();
		for (var i=0;i<lastRow.length;i++) {
			var cube = lastRow[i];
			cube.position.z -= gridDepth + gridDepth*cubePadding;
		}
		var newRow = shuffle(lastRow);
		grid.unshift(shuffle(newRow));
	}

	
	requestAnimationFrame(render);
	renderer.render(scene, camera);
}


init();

}
</script>
</head>

<body>
    
</body>
</html>
